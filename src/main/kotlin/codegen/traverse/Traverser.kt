package codegen.traverse

import codegen.*
import scheme.Tree
import java.io.ByteArrayOutputStream
import java.io.OutputStream
import java.nio.charset.Charset
import kotlin.random.Random

/**
 * Uses the tree to generate concrete code for each node
 * @param tree is generated by [TreeBuilder]
 */
class Traverser(private val tree: Tree) {

    val heads: MutableList<GenNode> = mutableListOf()
    private val availableVars: MutableMap<Variable, Int> = mutableMapOf()

    fun traverse() {
        tree.heads.forEachIndexed { idx, head ->
            assert(head.type == Elem.CLASS)
            val genNode = GenClassNode()
            val name = generateClassName()
            genNode.type = Elem.CLASS
            val list = heads.subList(0, idx).filterIsInstance<GenClassNode>()
            var parentClass: Clazz? = null
            if (rand(0, 10) > 5 && list.isNotEmpty()) {
                parentClass = list[rand(0, list.size)].classInfo
            }
            genNode.classInfo = Clazz(name, parentClass) // inheritance
            val actualMethods = parentClass?.methods
            actualMethods?.forEach { it.clazz = name }
            parentClass?.let { genNode.classInfo!!.methods.addAll(actualMethods!!) }
            genNode.text = classDecl(name, parentClass) + openFPar()
            heads.add(genNode)
            buildClassBody(head, genNode, name)
        }
    }

    private fun buildClassBody(treeNode: Tree.Node, classNode: GenClassNode, className: String) {
        treeNode.children.forEach { child ->
            when (child.type) {
                Elem.METHOD -> {
                    availableVars.clear()
                    val genChild = GenMethodNode()
                    genChild.type = Elem.METHOD
                    val type = getRandomType()
                    val methodName = generateMethodName(className)
                    val (methodBody, throws) = buildMethodBody(type, child, genChild, methodName, classNode)
                    val method = Method(methodName, type, methodBody, listOf(), className, throws)
                    genChild.methodInfo = method
                    genChild.text = methodDecl(method, throws)
                    classNode.children.add(genChild)
                    classNode.classInfo!!.methods.add(method)
                }

                Elem.FIELD -> {
                    val genChild = GenNode()
                    genChild.type = Elem.FIELD
                    val type = getRandomType(false)
                    val field = Field(generateFieldName(className), type, getDefaultValue(type))
                    genChild.text = fieldDecl(field) + semicolon()
                    classNode.children.add(genChild)
                    classNode.classInfo!!.fields.add(field)
                }

                else -> {}
            }
        }
    }

    private fun buildMethodBody(
        type: VarType,
        node: Tree.Node,
        genNode: GenNode,
        methodName: String,
        classNode: GenClassNode
    ): Pair<String, Boolean> {
        val throws = mutableListOf(false)
        node.children.forEach { ch -> processChild(ch, type, genNode, methodName, classNode, throws, depth = 0) }
        val baos = ByteArrayOutputStream()
        gatherMethodBody(genNode, baos)
        baos.write("${returnStmtDefault(type)}${semicolon()}".toByteArray())
        node.children.clear()
        genNode.children.clear()
        return Pair(baos.toString(Charset.defaultCharset()), throws[0])
    }

    /**
     * @param type - return type of method
     */
    private fun processChild(
        current: Tree.Node,
        type: VarType,
        genNode: GenNode,
        methodName: String,
        classNode: GenClassNode,
        throws: MutableList<Boolean> = mutableListOf(),
        depth: Int = 0
    ) {
        when (current.type) {
            Elem.VAR_DECL -> {
                val genChild = GenNode()
                val variable = Variable(generateVarName(methodName), getRandomType(false), false)
                availableVars[variable] = depth
                genChild.text = varDecl(variable) + semicolon()
                genNode.children.add(genChild)
            }

            Elem.METHOD_CALL -> {
                val methodsToCall = mutableListOf<Method>()
                heads.filterIsInstance<GenClassNode>().forEach { h ->
                    h.classInfo?.methods?.forEach { methodsToCall.add(it) }
                }
                if (methodsToCall.isEmpty()) return
                else {
                    val method = methodsToCall[rand(0, methodsToCall.size)]
                    val genChild = GenNode()
//                    val variable = Variable(generateVarName(methodName), method.returnType)
                    val variable = getVariable(methodName, method.returnType, depth)
                    val (call, t) = methodCall(method, variable, listOf())
                    genChild.text = call
                    if (t) throws[0] = true
                    genNode.children.add(genChild)
                }
            }

            Elem.IF -> {
                val genChild = GenNode()
                val ifStmt = ifStmt(constructCondition(classNode))
                genChild.text = ifStmt + openFPar() // todo duplicated code
                genNode.children.add(genChild)
                for (ch in current.children) {
                    processChild(ch, type, genChild, methodName, classNode, throws, depth + 1)
                    availableVars.entries.removeAll { (_, v) -> v > depth }
                    if (ch.type == Elem.RETURN || ch.type == Elem.EXCEPTION) break
                }
                val baos = ByteArrayOutputStream()
                gatherIfBody(genChild, baos)
                baos.write(closeFPar().toByteArray())
                genChild.text = baos.toString(Charset.defaultCharset())
                current.children.clear()
                genChild.children.clear()
            }

            Elem.FOR -> {
                val genChild = GenNode()
                val typee = listOf(VarType.INT, VarType.FLOAT, VarType.LONG)[rand(0, 3)]
//                val i = Variable(generateVarName(methodName), typee)
                val i = getVariable(methodName, typee, depth + 1)
                val n = getDefaultValue(i.type)
                var start = ""
                while (start > n || start.isEmpty()) {
                    start = getDefaultValue(i.type)
                }
                val forStmt = forStmt(i, n, start)
                genChild.text = forStmt + openFPar()
                genNode.children.add(genChild)
                for (ch in current.children) {
                    processChild(ch, type, genChild, methodName, classNode, throws, depth + 1)
                    availableVars.entries.removeAll { (_, v) -> v > depth }
                    if (ch.type == Elem.RETURN) break
                }
                val baos = ByteArrayOutputStream()
                gatherIfBody(genChild, baos)
                baos.write(closeFPar().toByteArray())
                genChild.text = baos.toString(Charset.defaultCharset())
                current.children.clear()
                genChild.children.clear()
            }

            Elem.RETURN -> {
                val genChild = GenNode()
                genChild.text = returnStmtDefault(type) + semicolon()
                genNode.children.add(genChild)
            }

            Elem.EXCEPTION -> {
                val genChild = GenNode()
                genChild.text = throwEx() + semicolon()
                genNode.children.add(genChild)
                throws[0] = true
            }

            else -> {}
        }
    }


    private fun getVariable(methodName: String, type: VarType, depth: Int): Variable {
        return if (rand(0, 2) == 0 || availableVars.filter { it.value <= depth && it.key.type == type && it.key.available }.isEmpty()) {
            val variable = Variable(generateVarName(methodName), type, false)
            availableVars[variable] = depth
            variable
        } else {
            val v = availableVars.filter { it.value <= depth && it.key.type == type && it.key.available }.toList().shuffled()[0].first
            v.exists = true
            println(v.name)
            v
        }
    }

    private fun constructCondition(classNode: GenClassNode): String {
        val charPool: List<Char> = ('a'..'z') + ('A'..'Z') + ('0'..'9')
        val opsPool = listOf(">", "<", ">=", "<=", ">", "<", ">=", "<=", "!=")
        if (rand(0, 2) < 3) {
            classNode.classInfo!!.fields.shuffle()
            classNode.classInfo!!.fields.forEach {
                return when (it.type) {
                    VarType.INT -> "${it.name} ${opsPool[rand(0, opsPool.size)]} ${rand(-1000, 2000)}"
                    VarType.LONG -> "${it.name} ${opsPool[rand(0, opsPool.size)]} ${Random.nextLong(3214L, 136812497L)}"
                    VarType.FLOAT -> "${it.name} ${
                        opsPool[rand(
                            0,
                            opsPool.size
                        )]
                    } ${(Random.nextFloat() * Random.nextInt(2435))}"

                    VarType.STRING -> "${it.name}.length() ${opsPool[rand(0, opsPool.size)]} ${rand(4, 15)}"
                    VarType.BOOL -> it.name
                    VarType.CHAR -> "${it.name} ${opsPool[rand(0, opsPool.size)]} '${charPool[rand(0, charPool.size)]}'"
                    else -> "true"
                }
            }
        } else {
            classNode.classInfo!!.methods.shuffle()
            classNode.classInfo!!.methods.forEach {
                return when (it.returnType) {
                    VarType.INT -> "${it.name}() ${opsPool[rand(0, opsPool.size)]} ${rand(-1000, 2000)}"
                    VarType.LONG -> "${it.name}() ${opsPool[rand(0, opsPool.size)]} ${
                        Random.nextLong(
                            3214L,
                            136812497L
                        )
                    }"

                    VarType.FLOAT -> "${it.name}() ${
                        opsPool[rand(
                            0,
                            opsPool.size
                        )]
                    } ${(Random.nextFloat() * Random.nextInt(2435))}"

                    VarType.STRING -> "${it.name}().startsWith(\"${charPool[rand(0, charPool.size)]}\")"
                    VarType.BOOL -> "${it.name}()"
                    VarType.CHAR -> "${it.name}() ${opsPool[rand(0, opsPool.size)]} '${
                        charPool[rand(
                            0,
                            charPool.size
                        )]
                    }'"

                    else -> "true"
                }
            }
        }
        return "true"
    }

    private fun gatherMethodBody(node: GenNode, outputStream: OutputStream) {
        outputStream.write(node.text.toByteArray())
        node.children.forEach { gatherMethodBody(it, outputStream) }
    }

    private fun gatherIfBody(node: GenNode, outputStream: OutputStream) {
        outputStream.write(node.text.toByteArray())
        node.children.forEach { gatherIfBody(it, outputStream) }
    }
}

open class GenNode {
    val children: MutableList<GenNode> = mutableListOf()
    var text = ""
    lateinit var type: Elem
//    var methodInfo: Method? = null // супер костыль потому что мне нужна инфа о методе, если нода метод (лучше сделать отдельный класс!)
}

class GenMethodNode : GenNode() {
    var methodInfo: Method? = null
}

class GenClassNode : GenNode() {
    var classInfo: Clazz? = null
}